<!DOCTYPE html>
<html lang="en">
<head>
  <title>The OpTiMSoC Blog</title>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <!-- external CSS -->
  <link href="//netdna.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">

  <!-- our own CSS (must be include after bootstrap.css!) -->
  <link rel="stylesheet" href="/css/optimsoc.css"/>

  <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
    <script src="/js/html5shiv.js"></script>
    <script src="/js/respond.min.js"></script>
  <![endif]-->

  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />

  <!-- Google Web Fonts -->
  <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,600,700,900" rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600,700" rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=Fredericka+the+Great" rel="stylesheet" type="text/css">
</head>
<body  data-offset='50' data-spy="scroll" data-target="">
  <!-- top navigation bar -->
  <nav class="navbar navbar-fixed-top optimsoc-nav" role="navigation">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/index.html" alt="OpTiMSoC"><span class="wordmark">OpTiMSoC</span></a>
      </div>
      <div class="navbar-collapse collapse">
        <ul class="nav navbar-nav">
          <li><a href="/download.html">Download</a></li>
          <li><a href="/docs/index.html">Documentation</a></li>
          <li><a href="/getinvolved.html">Get involved</a></li>
          <li><a href="/about.html">About</a></li>
          <li><a href="/blog">Blog</a></li>
        </ul>
      </div>
    </div>
  </nav>

  <div class="container" id="maincontent">
  

  <h1>The OpTiMSoC Blog</h1>

<p>In our blog we regularly post about the status of the project, things we figured out while working on it and other things that might come to our mind. Please contact us if you want to share your experience with OpTiMSoC, guest posts are always welcome!</p>


  <h2><a href="/blog/2021/01/26/demonstrator.html">OpTiMSoC Enabled Demonstrator System with Fault-Tolerant NoC</a></h2>
  <p class="optimsoc-blog-meta">by Max Koenen, posted on 26 January 2021
  <p><p>Although it has been silent around OpTiMSoC in recent months, some development is still ongoing.
Based on OpTiMSoC, a demonstrator system has been developed in the scope of the <a href="https://www.aramis2.org/">ARAMiS II</a> research project and has since been further improved.
This blog post describes the demonstrator system, its architecture and building blocks, and the alterations and extensions made to OpTiMSoC in order to build it.</p>

</p>

  <h2><a href="/blog/2019/06/16/award.html">OpTiMSoC wins the Eurolab4HPC Open Source Project Award!</a></h2>
  <p class="optimsoc-blog-meta">by Philipp Wagner, posted on 16 June 2019
  <p><p>How exciting!
At the <a href="https://fossi-foundation.org/wosh/">Week of Open Source Hardware (WOSH)</a> in Zürich, OpTiMSoC co-won the <a href="https://www.eurolab4hpc.eu/open-source/call/">Eurolab4HPC Open Source Project Award</a>!
We’re very excited and honored to see the efforts we put into OpTiMSoC being more widely recognized.
Thanks a lot to the sponsors of this award!</p>

<p>The other prices went to <a href="http://nyuzi.org/">Nyuzi</a>, a processor for highly parallel and GPGPU applications, and <a href="https://fusesoc.net/">FuseSoC</a>, a hardware package manager and build tool which we use in OpTiMSoC!</p>

<p>You can find OpTiMSoC, Nyuzi, FuseSoC, and many other great projects, listed at the <a href="https://www.eurolab4hpc.eu/open-source/">Open Source contributions page</a>.</p>

<center>
<img alt="Stefan and Philipp accept the award at WOSH" src="/img/posts/2019-06-16-award/award_philipp_stefan.jpg" title="Philipp and Stefan accept the award at WOSH" width="50%" />
</center>
</p>

  <h2><a href="/blog/2018/12/20/release.html">2018.1 Release: Linux, Debugging, Automation, and Tons of Fixes</a></h2>
  <p class="optimsoc-blog-meta">by Philipp Wagner, posted on 20 December 2018
  <p><p>Woohoo! After more than two years of work and 479 git commits later we are very proud to present the all-new 2018.1 release of OpTiMSoC!
A look at the statistics gives a first impression of how large this release is: <code class="language-plaintext highlighter-rouge">diffstat</code> tells us about 973 files changed, 133,697 lines inserted and 58,806 lines deleted.
Or in other words, the code size increased by 74,891 lines!
How do those lines of code translate into functionality, you may ask?
Let’s have a closer look.</p>

<h2 id="debug-infrastructure">Debug Infrastructure</h2>

<p>The debug infrastructure of OpTiMSoC is essential in getting code running on the system, in debugging it, and in performing measurements.
Over the last year we have fully re-implemented the <a href="https://github.com/opensocdebug/osd-sw">host software of the debug system</a> as part of Open SoC Debug (OSD), and imported it back into OpTiMSoC.
Together with this rewrite we extended and improved the <a href="https://opensocdebug.readthedocs.io/en/latest/02_spec/index.html">OSD specification document</a> to be even more complete, flexible, and robust.</p>

<p>Other changes:</p>

<ul>
  <li>A rock-solid off-chip interface is key: if developers cannot reliably access the SoC frustration levels can rise quickly. To avoid that, Max significantly improved the UART and USB3 (Cypress FX3) backends of <a href="https://www.glip.io">GLIP</a>, which provide the off-chip interface for OSD and consequently for OpTiMSoC.</li>
  <li>The implementation of the off-chip interfaces are now free of vendor primitives, making the porting between FPGAs easier than ever.</li>
  <li>New and improved Python bindings make it easy to interact with an OpTiMSoC system in an automated way.</li>
  <li>Last but not least, a new implementation of the UART Device Emulation Module within Open SoC Debug by Thomas Leyk was the last remaining blocker to get Linux up and running on OpTiMSoC.</li>
</ul>

<h2 id="refreshed-network-on-chip-noc-implementation">Refreshed Network on Chip (NoC) Implementation</h2>

<p>In previous generations of OpTiMSoC we relied on a NoC implementation called LISNoC.
Developed as part of a research project a couple years ago it has shown its age in various places.
Stefan took up the job of reimplementing significant parts of it, leading to a design which is easier to understand and more flexible as a result.</p>

<h2 id="testing-and-automation">Testing and Automation</h2>

<p>OpTiMSoC is complex: hardware, software, tooling, all need to work together to form a feature-rich System on Chip.
To ensure that we don’t accidentally break functionality we have added more tests on various levels.
The tests can be executed manually by every developer, and are executed automatically: some on every check-in, some once a day.</p>

<ul>
  <li>Static analysis helps to catch bugs early. For hardware, we are making use of Spyglass Lint to check the code for common errors.</li>
  <li>To test and verify the functionality of our hardware modules, we have added more <a href="https://github.com/potentialventures/cocotb">cocotb tests</a> to the tree.</li>
  <li>All software imported from Open SoC Debug is tested extensively with <a href="https://app.shippable.com/github/opensocdebug/osd-sw">unit tests and static analysis tools</a> to avoid regressions and to catch bugs like memory leaks early. Look at the configuration in the <a href="https://github.com/opensocdebug/osd-sw">opensocdebug/osd-sw</a> repository for more details.</li>
  <li>All steps in the tutorial within the user guide are now covered by automated tests. Even the tutorial showing how to build and flash Linux on an OpTiMSoC system running on an FPGA is fully <a href="https://github.com/optimsoc/optimsoc/blob/933cc88e4a0e19741521a4a286ad2525086ad9cf/test/systemtest/test_tutorial.py#L393">performed and checked as part of a test</a>. This allows us to say: our tutorials always work!</li>
  <li>Finally, we have fully automated our test and build infrastructure using Travis (directly visible on GitHub) and GitLab CI (for nightly builds using internal infrastructure). Read more about that in a <a href="/blog/2018/12/18/ci.html">separate blog post</a>.</li>
</ul>

<h2 id="user-experience">User Experience</h2>

<p>OpTiMSoC is used at TUM for research and teaching purposes.
With many different people working on it it is essential to provide a great out-of-the-box user experience.
Many small changes in this regard accumulated over the period of this release.</p>

<ul>
  <li>The steps needed to get started with OpTiMSoC have been reduced. For example, all dependencies can be now installed with a single script.</li>
  <li>A new tool, <code class="language-plaintext highlighter-rouge">optimsoc-pgm-fpga</code>, has been added to help flashing a bitstream onto an FPGA.</li>
  <li>Initially we shipped our own version of FuseSoC. Now that all of our patches have made it upstream we were able to rely on the upstream version, which is easily installable through <code class="language-plaintext highlighter-rouge">pip</code>.</li>
  <li>Good documentation makes a developer’s life so much easier. This time around we added <a href="https://www.optimsoc.org/docs/2018.1/api/index.html">API documentation for our SoC software libraries</a>, documented <a href="https://www.optimsoc.org/docs/2018.1/refman/networkonchip.html">the NoC implementation</a>, and added a <a href="https://www.optimsoc.org/docs/2018.1/refman/porting.html">guide how to port OpTiMSoC to new FPGAs</a>.</li>
  <li>It might seem like a odd entry in the category “user experience,” but it is an important one: we integrated a fan controller for the VCU108 board, significantly reducing the noise level produced by this board.</li>
  <li>Finally, we added a <a href="https://github.com/optimsoc/optimsoc/blob/master/devenv/install-optimsocide.sh">script to automatically install an Eclipse IDE</a> with all recommended settings to develop with and on OpTiMSoC.</li>
</ul>

<h2 id="linux-support">Linux Support</h2>

<p>Most users of OpTiMSoC run baremetal software on it, i.e. programming it like a microcontroller without any operating system.
Supporting advanced operating systems has always been a dream, but getting there required a lot of work.
But with all the small and large changes in this release and in the previous releases, we finally were able to make our dream come true: reliably boot Linux on OpTiMSoC.
Partly responsible for this dream is also the work of Stafford Horne, who worked relentlessly to update the OpenRISC port of Linux upstream and to incorporate all the changes that accumulated over the years.</p>

<p>Read more about that in <a href="/blog/2018/12/19/linux.html">Linux on OpTiMSoC: How many small steps unlock a whole new world</a>.</p>

<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Wp_2eORlWek" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
</center>

<h2 id="contributors">Contributors</h2>

<p>This release would not have happened without the continued great work of our contributors.
In this release the following people contributed.</p>

<ul>
  <li>Shivam Aggarwal</li>
  <li>Franz Biersack</li>
  <li>Annika Fuchs</li>
  <li>Max Koenen</li>
  <li>Pedro H. Penna</li>
  <li>Philipp Wagner</li>
  <li>Stefan Wallentowitz</li>
</ul>
</p>

  <h2><a href="/blog/2018/12/19/linux.html">Linux on OpTiMSoC: How many small steps unlock a whole new world</a></h2>
  <p class="optimsoc-blog-meta">by Philipp Wagner, posted on 19 December 2018
  <p><p>Some projects we take upon ourselves are done quickly: start, do the work, profit.
Others take a bit longer.
And then there are these projects which seem to linger forever in an “almost done” state.
Just one more small thing and we’ll be done.
A small fix here.
An extension to a module there.
A new component elsewhere.
And so it goes on, and on, and on.
For days, for weeks, for years.
Adding Linux support to OpTiMSoC is such a story.
But there’s a happy end: Linux support has finally arrived!</p>

<p>This blog post tells the story of how Linux can be now used on OpTiMSoC, and shines a bit of light on the obstacles along the way.</p>

<h2 id="how-it-all-looks-in-the-end">How it all looks in the end</h2>

<p>A picture is always a good starting point, so let’s start with a picture.</p>

<p><img src="/img/posts/2018-12-19-linux/architecture.jpg" alt="An overview of how Linux runs on OpTiMSoC" title="An overview of how Linux runs on OpTiMSoC" /></p>

<p>The picture shows a simplified version of the whole system we’ve set up to run Linux on OpTiMSoC.
On the left is the “Host PC” where the developer sits.
On the bottom at right is the FPGA board, in this case a <a href="https://reference.digilentinc.com/reference/programmable-logic/nexys-4-ddr/start">Nexys 4 DDR board</a> (recently renamed to Nexys A7-100T) containing a Xilinx Artix 7 FPGA (the XC7A100T to be exact).
The board is connected to the Host PC through USB, and the FPGA is programmed with a bitstream containing our SoC design.</p>

<p>The design (all described in Verilog) is shown on the top right.
At its center is the Wishbone bus which connects a single OpenRISC CPU core, DDR memory, and a 16550 UART module (we’ll get to that in a minute).
Supporting this infrastructure is the debug system.
It connects to the memory and the UART and enables them to speak with the Host PC.</p>

<h2 id="what-we-want-to-achieve-and-what-not">What we want to achieve (and what not)</h2>

<p>Before we go into all the gory details, let’s first discuss the goals of this whole exercise.</p>

<ul>
  <li>We want to have a Linux-based operating system running on the OpenRISC CPU core on the FPGA.</li>
  <li>We want to see the output produced by Linux (e.g. during boot), and we want to interact with it by typing commands and seeing their output.
We call this way of interaction “virtual serial console.”</li>
  <li>We also want to use the Host PC to control the system on the FPGA: we want to load our Linux operating system into the memory on the FPGA, and we want to start and reset it.</li>
</ul>

<p>To avoid confusion, let’s also discuss the things we <em>don’t</em> want to achieve.</p>

<ul>
  <li>We don’t have a monitor connected to the FPGA.
Our only way of interacting with the system is through the virtual serial console.</li>
  <li>We don’t have persistent storage hooked up to the system, like an SD card or flash memory.
Once the FPGA is turned off all software is gone and needs to be loaded onto the system again through the Host PC.</li>
</ul>

<p>With the goals and non-goals clearly stated let’s have a look at how all this machinery can be brought to life.</p>

<h2 id="lets-cook-up-a-linux-system-on-optimsoc">Let’s cook up a Linux system on OpTiMSoC!</h2>

<p>Before we can get started we first need to prepare our “ingredients”.
Don’t worry for now if you don’t know where to get these “ingredients” from, we’ll discuss that later.</p>

<ol>
  <li>A bitstream for the FPGA containing the SoC design as shown in the picture.</li>
  <li>Software on the Host PC (which also runs Linux) to interact with the FPGA.</li>
  <li>Finally, we need a Linux root image. That’s the software which we will execute on the OpenRISC CPU.</li>
</ol>

<p>With everything prepared let’s start our recipe, the steps we need to take to boot up Linux on OpTiMSoC are simple.</p>

<ol>
  <li>Program the FPGA with the bitstream.</li>
  <li>Connect to the system through the debug infrastructure.</li>
  <li>The host software detects the UART emulation module on the FPGA and provides a virtual serial port (e.g. <code class="language-plaintext highlighter-rouge">/dev/pts/1</code>).</li>
  <li>On the Host PC, open a terminal application and connect to the virtual serial port.</li>
  <li>Write the Linux root image to the DDR memory using the host software.</li>
</ol>

<p>That’s it!
Once the Linux root image has been written to the DDR memory the CPU starts executing it.
In our case, that means Linux boots, and as soon as that’s done, greets you with a login screen: “Welcome to OpTiMSoC”!
You can now log into the system as root user, and interact with it as you would do with any other Linux system.</p>

<p>Don’t believe me? Have a look at the video then.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Wp_2eORlWek" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<h2 id="where-do-all-the-components-come-from">Where do all the components come from?</h2>

<p>Everything you’ve seen in the video is using published components of OpTiMSoC.
Head to the <a href="https://www.optimsoc.org/download.html">download page</a> to get the latest release.
This gives you pre-built versions of all tools and bitstreams used in this demo.
The only thing you need to build yourself it the Linux image.</p>

<p>The Linux root image we’re using is similar to a self-extracting ZIP file: it contains the Linux kernel together with an initial ramdisk (initramfs).
That’s essentially a “hard drive image” loaded into memory, with all tools contained in it: a shell, tools like <code class="language-plaintext highlighter-rouge">ps</code> or <code class="language-plaintext highlighter-rouge">ls</code>, and additional software we chose to add.</p>

<p>To prepare such a image we are using <a href="http://buildroot.org/">buildroot</a>, a project dedicated to exactly that purpose.
Buildroot takes a configuration file as input, and produces a <code class="language-plaintext highlighter-rouge">vmlinux</code> file as output.
That’s just normal ELF file which we program into the memory on the FPGA board.</p>

<p>All our custom configuration is contained in the <a href="https://github.com/optimsoc/optimsoc-buildroot">optimsoc/optimsoc-buildroot</a> repository.
The user guide contains <a href="https://www.optimsoc.org/docs/master/user_guide/tutorials.html#run-linux-on-optimsoc">detailed instructions how to make it all work</a>.</p>

<h2 id="why-did-it-take-so-long">Why did it take so long?</h2>

<p>The system shown above looks sufficiently simple, doesn’t it?
That’s what we thought as well, and again and again.
It turns out, to have something as complex as Linux running on a custom system actually requires getting a lot of small and by itself insignificant details right.</p>

<ul>
  <li>The off-chip connection must be fully reliable. Making sure that no packets drop, even in rare backpressure scenarios, took a while.
Max did great work in creating <a href="https://github.com/TUM-LIS/glip/blob/master/src/tools/io_stress_test.c">stress tests</a> for our UART and USB3 interfaces (all of them part of <a href="https://www.glip.io">GLIP</a>) and debugging their fallout.
Some days and nights went into the firmware for the Cypress FX3 chip, which doesn’t always behave as the datasheet would make one think …</li>
  <li>The second ingredient is of course Linux itself.
Stafford Horne did a great job to pick up work on the upstream Linux port and to steadily improve it.
Today, we can run an unpatched upstream Linux kernel on our system!</li>
  <li>One of the last steps was to add the <a href="https://opensocdebug.readthedocs.io/en/latest/02_spec/07_modules/dem_uart/index.html">DEM UART module</a> to <a href="https://www.opensocdebug.org">Open SoC Debug</a>.
This module emulates a <a href="https://en.wikipedia.org/wiki/16550_UART">16550 UART device</a> so that Linux can use its standard drivers to communicate.
But instead of sending all data to a physical UART port, the DEM UART module wraps it into Debug Packets, which are sent through the debug interconnect to the host PC, reusing the same infrastructure we use for loading the Linux root image into the memory.
This last step was completed by Thomas Leyk a couple of weeks ago.</li>
  <li>Finally, we needed a way to reproducibly build a Linux root image.
Thankfully, that’s rather easy thanks to buildroot.</li>
</ul>

<p>Not mentioned here is all the time spent on debugging small issues, fixing the build automation, and adding tests to ensure we don’t break our newly gained Linux functionality any more.
Today we have a <a href="https://github.com/optimsoc/optimsoc/blob/6fc1a2f6cef02bd24a8b63b4303f2a5488878c7c/test/systemtest/test_tutorial.py#L393">full Linux build happening every night, performing the exact same steps as you’ve seen in the video, and checking its outputs</a>.</p>

<h2 id="get-started">Get started</h2>

<p>Do you want to build your own Linux image for OpTiMSoC?
Do you want to try out what you’ve seen in the video?
Then head over to <a href="https://www.optimsoc.org/docs/master/user_guide/tutorials.html#run-linux-on-optimsoc">the tutorial in the user guide</a>!</p>

<p>With Linux running on OpTiMSoC we’ve unlocked a whole new world of possibilities – software can run with minimal porting effort, existing drivers can be reused, and much more.
The future is bright, and we’re excited to explore more ways of using OpTiMSoC!</p>
</p>

  <h2><a href="/blog/2018/12/18/ci.html">Code with Confidence: OpTiMSoC Always Works!</a></h2>
  <p class="optimsoc-blog-meta">by Philipp Wagner, posted on 18 December 2018
  <p><p>OpTiMSoC is a highly complex system.
If all goes to plan, software, hardware and tooling work together to form a well-integrated SoC (framework).
But as so often, the reality is less gloomy: changing a single line of code anywhere could lead to trouble anywhere else.
Finding out about breakages only weeks of months after the fact makes debugging a nightmare. [1]</p>

<p>Not any more.
After multiple years of despair and a lot of work we can finally say with confidence: “OpTiMSoC always works!”
In this blog post we’ll have a look at how we achieved this goal.</p>

<p>The first ingredient to our solution are (automated) tests.
OpTiMSoC comes with many tests on various levels up to the full system level; just type <code class="language-plaintext highlighter-rouge">make test</code> in your OpTiMSoC source tree to execute them.
But: the best tests are useless if they’re not run.
And that’s the problem:
Compiling all parts of OpTiMSoC and running the tests takes multiple hours.
Expecting developers to run all of them after every single change is unrealistic.
So we need a better solution, and the answer is (as so often) automation.
In this case, the automation is called <a href="https://en.wikipedia.org/wiki/Continuous_integration">Continuous Integration</a>, or CI for short.</p>

<p>CI is is not a new concept, of course.
It has been used in software development for almost two decades now.
Unfortunately, testing and CI in the hardware world are a bit more complicated than in the software world.</p>

<p>The first challenge are tools: While many of the tools we’re using are available as open source, not all of them are.
Particularly the tools to generate FPGA bitstreams (e.g. Xilinx Vivado) are closed source, and some of them require a license to operate.
Another challenge is the hardware itself: running tests on an FPGA board requires (unsurprisingly) an FPGA board, and a way to connect it to the test machine.
A third challenge is time: synthesizing an FPGA bitstream takes multiple hours.
Hence waiting for the full build and test to complete significantly reduces developer productivity.</p>

<p>Despite these challenges, we found a way to have extensive test coverage <em>and</em> fast developer feedback.
A two-staged solution gets us there.
The first stage are tests in <a href="http://travis-ci.org/">Travis CI</a>.
Travis is a commonly used continuous integration service which is free to use for open source projects.
It integrates nicely into GitHub and can be configured to run a build and test script on every check-in, and on every pull request.</p>

<p>We <a href="https://github.com/optimsoc/optimsoc/blob/master/.travis.yml">configured</a> <a href="https://github.com/optimsoc/optimsoc/blob/master/Dockerfile">Travis</a> to build OpTiMSoC and to run all simulation-based tests using Verilator.
If a Travis run indicates a successful build and test, we already know that all steps outlined in the <a href="/docs/master/user_guide/tutorials.html">user guide tutorial</a> up to (and including) the <a href="https://www.veripool.org/projects/verilator/wiki/Intro">Verilator</a>-based examples work as expected.</p>

<p>The second stage goes beyond what Travis can provide, as we now need access to commercial tools, associated licenses, and real hardware (e.g. FPGA boards).
Internally at TUM we have access to a hosted instance of GitLab, which comes with (among many other great things) an integrated continuous integration system, GitLab CI.
GitLab CI lets you attach “runners” to it.
A runner is nothing else than a PC with a piece of software installed, connecting it to the central GitLab server.
We have made a couple machines in our lab a “GitLab runner”.
All of them have access to our tools installed on a central NFS share, and some of them have FPGA boards connected to them.</p>

<p>Making use of this setup and combining it with <a href="https://github.com/optimsoc/optimsoc-autobuild/blob/master/.gitlab-ci.yml">over 200 lines of configuration file</a> we have created a fully automated continuous integration system.
Every night, a new build pipeline wakes up (so we don’t need to) and crunches data for more than four hours on up to four machines in parallel.</p>

<p>That’s how it looks in GitLab CI:
<img src="/img/posts/2018-12-18-ci/gitlab-pipeline.jpg" alt="A look at our build and test pipeline in GitLab CI" title="A look at our build and test pipeline in GitLab CI" /></p>

<p>Looking closer, the build pipeline consists of the following steps.</p>

<ul>
  <li>Get latest OpTiMSoC source code from the <code class="language-plaintext highlighter-rouge">master</code> branch.</li>
  <li>Run all cocotb-based hardware tests.</li>
  <li>Run Spyglass Lint on all hardware.</li>
  <li>Build OpTiMSoC itself (that’s mostly software tooling)</li>
  <li>Build seven different Verilator-based simulations models, from a small single-core, single-tile model without debug system up to a 2x2 mesh system with two cores per tile.</li>
  <li>Build four FPGA bitstreams for the <a href="https://store.digilentinc.com/nexys-4-ddr-artix-7-fpga-trainer-board-recommended-for-ece-curriculum/">Nexys 4 DDR</a> (recently renamed to <a href="https://store.digilentinc.com/nexys-a7-fpga-trainer-board-recommended-for-ece-curriculum/">Nexys A7-100T</a>) and <a href="https://www.xilinx.com/products/boards-and-kits/ek-u1-vcu108-g.html">VCU108</a> boards.</li>
  <li>Run the system tests in simulation and on real hardware. On real hardware, the tests use the Nexys 4 DDR board to run baremetal software, and to build, flash and boot a full Linux!</li>
  <li>If all went well, the resulting build artifacts (source files, simulation models, FPGA bistreams) are uploaded to <a href="https://bintray.com/optimsoc/nightly/">Bintray</a>, where anybody can download them.</li>
</ul>

<p>With all this automation in place you can now write a short script to always get the latest nightly build of OpTiMSoC, including FPGA bitstreams.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># figure out the latest version of OpTiMSoC [2]</span>
<span class="nv">LV</span><span class="o">=</span><span class="si">$(</span>curl <span class="nt">-sL</span> https://api.bintray.com/packages/optimsoc/nightly/optimsoc-src/versions/_latest  |  python <span class="nt">-c</span> <span class="s1">'import sys, json; print json.load(sys.stdin)["name"]'</span><span class="si">)</span>

<span class="c"># get the source archive</span>
curl <span class="nt">-sLO</span> https://dl.bintray.com/optimsoc/nightly/optimsoc-<span class="nv">$LV</span><span class="nt">-src</span>.tar.gz

<span class="c"># get the OpTiMSoC framework</span>
curl <span class="nt">-sLO</span> https://dl.bintray.com/optimsoc/nightly/optimsoc-<span class="nv">$LV</span><span class="nt">-base</span>.tar.gz

<span class="c"># and finally: get all examples with all bitstreams</span>
curl <span class="nt">-sLO</span> https://dl.bintray.com/optimsoc/nightly/optimsoc-<span class="nv">$LV</span><span class="nt">-examples</span>.tar.gz
curl <span class="nt">-sLO</span> https://dl.bintray.com/optimsoc/nightly/optimsoc-<span class="nv">$LV</span><span class="nt">-examples-ext</span>.tar.gz
</code></pre></div></div>

<p>You can find all CI configuration used for Travis in our <a href="https://github.com/optimsoc/optimsoc">main repository</a> (look for the <code class="language-plaintext highlighter-rouge">.travis.yml</code> and <code class="language-plaintext highlighter-rouge">Dockerfile</code> files).
The results of the Travis runs are also <a href="https://travis-ci.org/optimsoc/optimsoc">visible online</a>.</p>

<p>The configuration for the GitLab CI is contained in the <a href="https://github.com/optimsoc/optimsoc-autobuild">optimsoc-autobuild repository</a> (look for the <code class="language-plaintext highlighter-rouge">.gitlab-ci.yml</code> file).
However, this configuration is heavily tailored towards our internal infrastructure and won’t run anywhere else as-is.</p>

<p>So for now, go and give it a try!
Use OpTiMSoC to learn and teach, to explore and discover.
Have fun!</p>

<hr />

<p>[1] At least for light debugging. Heavy debugging, typically performed at night, avoids the problem of nightmares in an interesting way: no sleep, no nightmares.</p>

<p>[2] Getting the latest version first is a bit annoying, having a “latest” symlink would be easier of course. This seems to be a <a href="https://bintray.com/docs/api/#_dynamic_download">restriction Bintray has for their non-paying customers</a>. Having an additional line in a script is a fair price to pay a free service.</p>
</p>

  <h2><a href="/blog/2017/09/20/status.html">What's going on at OpTiMSoC?</a></h2>
  <p class="optimsoc-blog-meta">by Philipp Wagner, posted on 20 September 2017
  <p><p>Each year in September or early October the OpTiMSoC team attends <a href="https://orconf.org/">ORConf</a>, and this year was no exception.
In addition to exchanging a lot of ideas with friends and other open source enthusiasts, ORConf presents itself as a good opportunity to reflect on what has happened in OpTiMSoC land over the last year.</p>

<p>As it turns out, there’s a lot we forgot to talk about before!</p>

<ul>
  <li>OpTiMSoC got initial Linux support, thanks to the great work of <a href="https://sites.google.com/view/ppenna/">Pedro</a> during his Google Summer of Code. See <a href="/blog/2017/09/04/gsoc2917.html">this blog post</a> for more details. Also, none of this work would have been possible without the great support of Stafford Horne, the maintainer of the OpenRISC architecture on Linux.</li>
  <li>Our system-level tests are run continuously in Travis and make sure that the steps outlined in the tutorial documentation always work. Even though these tests are in simulation only, they are at least able to ensure that we don’t fundamentally break the code base when making changes.</li>
  <li>We extended the <a href="https://optimsoc.org/docs/master/refman/index.html">Reference Manual</a> and added <a href="https://optimsoc.org/docs/master/api/index.html">auto-generated API documentation</a> to the homepage.</li>
  <li>Stefan reimplemented the NoC. While the functionality stayed largely the same, the code is now easier to maintain.</li>
  <li>The Xilinx VCU108 board is now supported.</li>
  <li>A lot of debugging work, sweat and tears went into GLIP, especially the USB 3.0 transport (Cypress FX3). A huge thanks to Max for leading the effort on this and spending weeks on debugging tiny little bugs between the FPGA, the FX3 chip, its firmware and the host. Using USB 3 we can more than 100 MByte/s trace streams off-chip, which helped significantly in getting the Linux port up and running.</li>
  <li>Finally: We went over 1024 commits!</li>
</ul>

<p>The future is always hard to predict (and history has told us many times that we’re particularly bad at predictions), but some serious things are cooking and might come to you soon.</p>

<ul>
  <li>Multi-core Linux support. The required Linux patches are currently under review and are scheduled to get into Linux in the 4.15 release.</li>
  <li>Debug infrastructure improvements. Most of that work is happening over at Open SoC Debug, but we’re actively involved and are constantly merging when things get ready.</li>
  <li>More NoC and network adapter improvements. We have quite a bit of research going on in this area, and we’ll try to make the results available as soon as they’re sufficiently usable in the general case.</li>
</ul>

<p>As always, if you have questions, let us know!
In addition to the <a href="mailto:optimsoc@lists.lrz.de">mailing list</a> you can find us on <a href="https://gitter.im/optimsoc/Lobby">Gitter in the optimsoc/Lobby channel</a>.</p>
</p>

  <h2><a href="/blog/2017/09/04/gsoc2917.html">GSoC 2017 Project: Integration of the OpenRISC Linux Port into OpTiMSoC</a></h2>
  <p class="optimsoc-blog-meta">by Pedro H. Penna, posted on 04 September 2017
  <p><p>Linux was ported to OpTiMSoC during the 2017’s Google Sumer of Code. This blog
post details the work that was accomplished during the project; and as well the work
that was left to be tackled.</p>

<p>To port Linux to OpTiMSoC, a new manycore configuration with a Host Tile was designed and
implemented. The Host Tile runs OpenRISC Linux and communicates with
applications running on Computing Tiles via message-passing through the
Network-on-Chip (NoC). Overall, the communication infrastructure is exported to
user-level through standard UNIX file system operations, thereby enabling
user-level applications running on the Host Tile to rely on a high-level
communication abstractions.</p>

<h2 id="i-design">I. Design</h2>

<p>Figure 1 presents and the design overview of this project. A manycore
configuration featuring six tiles is depicted, one host tile and five compute
tiles. The host tile has a UART device attached to it and runs the OpenRISC
port of Linux; whereas compute tiles runs user-level applications bare metal.
Processes running on the Host Tile and user-level applications running on the
Compute Tile communicate with one another via message-passing.</p>

<p><img src="https://lh6.googleusercontent.com/RNhSim8cI60Tlxoow31vsldGeG2oHcLEsdjJHKaWlBXlTWe6_WuH5Facrp2VGM3f4-DuX-BDt_V6569dTISxWqoTt8Q3JdXxr0r_XNMRo-S8y82hByMaatmNzrx_ERKgbBQktcHf" alt="" /></p>

<p><strong>Figure 1:</strong> Overview of the target manycore configuration.</p>

<p>The OpenRisc Linux kernel running on the Host Tile features a Network-on-Chip
(NoC) driver on which processes rely to send/receive messages. Operations on
this driver are exported to userland through the standard UNIX system calls for
manipulating files. Code Snippet 1 illustrates how a process running on the
Host Tile send messages based on this abstraction. As a side remark, note that
the user-level application should explicitly build the message header. In
future implementation, the idea is to have a user-level library that does this
job for the application. On the other hand, in Compute Tiles, user-level
applications rely on a baremetal message-passing library to carry out a
communication with other tiles.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main(int argc, char **argv)
{
    int fd;
    const char *devname = "/dev/noc";

    /* Open NoC device. */
    fd = open(devname, O_WRONLY);
    
    /* Write some data. */
    while (int i = 0; i &lt; 100; i++) {
        unsigned dest = 0x8000000;
        unsigned data = 0x0000dead;
        unsigned msg = dest | data;
        write(fd, &amp;msg, sizeof(unsigned));
    }
   
    /* Close NoC device. */
    close(fd);

    return (EXIT_SUCCESS);
}
</code></pre></div></div>

<h2 id="ii-noc-driver-implementation">II. NoC Driver Implementation</h2>

<p>To enable inter-tile communication, a NoC device driver for Linux was written.
This device driver was implemented as a dynamically loadable module and it exports operations on the NoC to userland through regular file system calls. The main internal  routines of the implemented driver are discussed next.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * Opens a NoC endpoint. The device minor number is used to
 * identify the target endpoint to open. Access to an endpoint
 * is exclusive, ie. only one process may use a given endpoint
 * at a time.
 */
int optimsoc_open(struct inode *, struct file *);

/*
 * Releases a NoC endpoint. The device minor number is is used
 * to identify the target  endpoint to release. Underlying
 * resources associated with the endpoint are released.
 */
int optimsoc_release(struct inode, struct file *);

/*
 * Sends messages over an endpoint. The device minor number
 * is used to identify the target endpoint to use on the
 * communication. Sending messages does not block the
 * calling process. The size of messages should be aligned
 * on word size (32 bits). Message headers should be built
 * on user-space.
 */
ssize_t optimsoc_write(struct file *, const char *, size_t, off_t);

/*
 * Receives messages over an endpoint. The device minor
 * number is used to identify the target endpoint to use on
 * the communication. Sending messages blocks the calling
 * process. Flits of a message are buffered in kernel land.
 */
ssize_t optimsoc_read(struct file *, const char *, size_t, off_t);
</code></pre></div></div>

<h2 id="iii-building-the-project">III. Building the Project</h2>

<p>Since the Linux source tree is not yet integrated into OpTiMSoC Project, you should follow the next steps to get it running on OpTiMSoC.</p>

<h3 id="part-1-setup-optimsoc">Part 1: Setup OpTiMSoC</h3>

<p>Follow the upstream online instructions at: https://www.optimsoc.org/docs/master/user_guide/installation.html</p>

<p><strong>In the end, set the <code class="language-plaintext highlighter-rouge">OPTIMSOC</code> environment variable to point to the
installation location of OpTiMSoC.</strong></p>

<h3 id="part-2-get-development-tools">Part 2: Get Development Tools</h3>

<p>To build Linux, you will need a slightly diferent toolchain than the one used to build OpTiMSoC.</p>

<ul>
  <li>Musl Toolchain</li>
  <li>Newlib Baremetal Toolchain</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir -p $HOME/toolchain

cd $HOME/toolchain

wget  https://github.com/openrisc/or1k-gcc/releases/download/or1k-5.4.0-20170218/or1k-elf-5.4.0-20170218.tar.bz2

tar -xjvf or1k-elf-5.4.0-20170218.tar.bz2

wget https://github.com/openrisc/or1k-gcc/releases/download/or1k-5.4.0-20170218/or1k-linux-musl-5.4.0-20170218.tar.bz2

tar -xjvf or1k-linux-musl-5.4.0-20170218.tar.bz2

wget https://github.com/openrisc/or1k-gcc/releases/download/or1k-5.4.0-20170218/or1k-linux-5.4.0-20170218.tar.bz2

tar -xjvf or1k-linux-5.4.0-20170218.tar.bz2
</code></pre></div></div>

<h3 id="part-3-build-unit-tests-optional">Part 3: Build Unit Tests (Optional)</h3>

<p>You can test your Linux build in OpTiMSoC with a simple distributed application:</p>

<ul>
  <li><strong>hello-linux:</strong> runs on a host tile on top of Linux and simply sends raw messages to a remote compute tile.</li>
  <li><strong>hello-baremetal</strong>: runs on a compute tile on baremental, and simply read messages that arrive at the local NoC adapater and print them on the screen.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export LIBS=$OPTIMSOC/soc/sw/lib/baremetal/libbaremetal.a

git clone https://github.com/optimsoc/linux-apps $HOME/linux-apps

cd $HOME/linux-apps/

export CC=$HOME/toolchain/or1k-linux-musl/bin/or1k-linux-musl-gcc


$CC hello-linux/hello.c -o hello-linux/hello

export CC=$HOME/toolchain/or1k-elf/bin/or1k-elf-gcc
export CFLAGS=”-I $OPTIMSOC/soc/sw/include/baremetal/”

$CC $CFLAGS hello-baremetal/hello.c -o hello-baremetal/hello $LIBS    
</code></pre></div></div>

<h3 id="part-4-build-linux">Part 4: Build Linux</h3>

<p>Setup toolchain.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export PATH=$PATH:$HOME/toolchain/or1k-linux/bin/
export ARCH=openrisc
export CROSS_COMPILE=or1k-linux-
</code></pre></div></div>

<p>(Optional) If you have built unit tests from Step 3, you should copy <code class="language-plaintext highlighter-rouge">hello-linux</code> to the the initramfs directory.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir -p $HOME/linux/arch/openrisc/initramfs/
    cp $HOME/linux-apps/hello-linux/hello $HOME/linux/arch/openrisc/initramfs/
</code></pre></div></div>

<p>Clone and build Linux. Note that this is done in three steps: (i) build system configuration; (ii) build dynamic modules; and (iii) build the kernel.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/optimsoc/linux.git $HOME/linux

cd $HOME/linux

make optimsoc_defconfig
make modules
make
</code></pre></div></div>

<h2 id="iii-conclusions">III. Conclusions</h2>

<p>During this GSoC project I wrote a Linux NoC driver for OpTiMSoC-based platforms. This driver was implemented as a dynamically loadable module and used standard file system kernel calls to export the message passing of the underlying platform to user space. 
Concerning the current  implementation, the following work remains open:</p>

<ul>
  <li><strong>[Enhancement] Enable Endpoints to Be Multiplexed.</strong> In the current implementation, only process at a time may use a given endpoint. A nice feature to have would be to enable multiple processes to concurrently use an endpoint.</li>
  <li><strong>[Bug Fix] Properly Install the Interrupt Handler.</strong> In the current implementation, when the interrupt handler is registered, the boot sequence halts when running on Verilator/FPGA. Interrupt-firing behavior should be investigated and the interrupt handler setup should be fixed accordingly.</li>
</ul>
</p>

  <h2><a href="/blog/2016/09/02/release.html">2016.1 Release: Heart Surgery for FuseSoC and Open SoC Debug</a></h2>
  <p class="optimsoc-blog-meta">by Philipp Wagner, posted on 02 September 2016
  <p><p>It’s OpTiMSoC release time! After a bit over half a year of work, we’re proud to announce our first release in this year, 2016.1.
It comes with many great new features, but two are especially noteworthy: our switch to FuseSoC and the integration of Open SoC Debug.
Both new features strengthen our collaborations with other projects – because sharing is caring!</p>

<h2 id="part-1-fusesoc">Part 1: FuseSoC</h2>
<p>Traditionally, every digital hardware project had its own build system and its own way of managing dependencies, and OpTiMSoC was no exception.
Especially for people coming from the software world with all the nice package managers and module repositories specialized to the various programming languages, this seems a bit arcane.
Fortunately, our friend Olof Kindgren has put a lot of work into FuseSoC, a tool that fills exactly that gap: a package manager, dependency solver and build system for digital hardware designs.</p>

<p>For this release, we took the chance to perform a bit of heart surgery: rip out our existing build infrastructure based on TCL files, and replace it with FuseSoC’s core description files.</p>

<p>While we restored all the existing functionality, i.e. to run Verilator, Vivado Synthesis and the various simulation tools through FuseSoC, we discovered a couple of issues with FuseSoC that are not all fixed upstream yet. While we work on getting all our changes upstream, we ship OpTiMSoC with a slightly modified FuseSoC version, which is available by calling <code class="language-plaintext highlighter-rouge">optimsoc-fusesoc</code>. One main reason is that we are using the
new <code class="language-plaintext highlighter-rouge">&lt;vendor&gt;:&lt;library&gt;:&lt;name&gt;:&lt;version&gt;</code> (vlnv) naming scheme that we prototyped
before it is now also getting into upstream. Beside that, we added
Vivado and better xsim support, that we will also get into the
official fusesoc version soon.</p>

<p>So what does that mean for you?
Synthesizing a 2x2 tiled multi-core system with four compute tiles using Xilinx Vivado is now as simple as</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>optimsoc-fusesoc <span class="nt">--cores-root</span> <span class="nv">$OPTIMSOC_SOURCE</span>/examples build optimsoc:examples:system_2x2_cccc_nexys4ddr
</code></pre></div></div>

<p>Building and running a Verilator-based simulation of a single compute tile with two mor1kx cores is not much harder:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>optimsoc-fusesoc <span class="nt">--cores-root</span> <span class="nv">$OPTIMSOC_SOURCE</span>/examples sim optimsoc:examples:compute_tile_sim <span class="nt">--NUM_CORES</span> 2
</code></pre></div></div>

<p>See the <a href="http://www.optimsoc.org/docs/2016.1/user-guide/chap_develop-optimsoc.html#S1">documentation</a> for more examples.</p>

<h2 id="part-1b-sharing-hardware-modules">Part 1b: Sharing Hardware Modules</h2>
<p>By switching to FuseSoC, we are now able to much easier share hardware modules with other projects.
In the old days, sharing meant copying HDL files around, and missing updates whenever there were new releases.
With FuseSoC, it’s easy to simply point to a Git repository containing HDL files, or even download a <a href="https://github.com/wallento/fusesoc_cores/blob/master/cores/micron/mt47h64m16hr-25e/mt47h64m16hr-25e.core">ZIP file with HDL files from a web site (a great usage example of FuseSoC!)</a>.</p>

<p>We use this feature to factor out and share some of our modules.</p>

<ul>
  <li>
    <p>We share our board support packages, like the one for the Nexys 4 DDR board, with others.
You can find them <a href="https://github.com/wallento/fusesoc_cores/">here</a>.</p>
  </li>
  <li>
    <p>We also include the HDL files for GLIP (our host communication library) and Open Soc Debug (more about that below) from their upstream sources.</p>
  </li>
</ul>

<p>Right now, we ship all these sources inside our source tree to make changes and editing easier.
If the rate of changes decreases over time, we can move to directly including these dependencies from upstream.</p>

<h2 id="part-2-open-soc-debug-osd">Part 2: Open SoC Debug (OSD)</h2>
<p>OpTiMSoC has always included a rather sophisticated trace-based debug infrastructure.
As it turns out, we’re not the only open source digital hardware project that needs such a infrastructure.
In order to share effort, we founded, together with the <a href="http://www.lowrisc.org/">LowRISC project</a> and in close cooperation with the <a href="http://www.pulp-platform.org/">PULPino project</a>, <a href="http://opensocdebug.org/">Open SoC Debug</a> (OSD).</p>

<p>The goal of this project is to collaborate on debug and diagnosis components, as they are included in OpTiMSoC: components for instruction traces, system traces, memory initialization, and much more.</p>

<p>In this OpTiMSoC release, we see the first results of this collaboration.
Our debug infrastructure is now based on OSD.
All debug features that were available previously are still there, and some features are new:</p>

<ul>
  <li>System Traces (using <code class="language-plaintext highlighter-rouge">printf()</code> inside the SoC software, or the <code class="language-plaintext highlighter-rouge">OPTISMOC_TRACE</code> macro)</li>
  <li>Function traces</li>
  <li>Reading and writing of memories in the system (now with an additional memory test and verify feature)</li>
  <li>Now you can also write ELF files directly into the memory, without using <code class="language-plaintext highlighter-rouge">objdump</code> to convert them first.</li>
  <li>Not really a OSD feature, but we still profit from it by using GLIP: You can now use 12 MBaud/s UART to connect to the debug system, in addition to JTAG or USB (depending on the board)</li>
</ul>

<p>The main visible difference today are new tools to communicate with the OpTiMSoC system.
Instead of our own tools like <code class="language-plaintext highlighter-rouge">optimsoc-cli</code>, we now use the OSD tools, like <code class="language-plaintext highlighter-rouge">osd-cli</code>.
You find much more about how to use them in the updated <a href="http://www.optimsoc.org/docs/2016.1/user-guide/chap_tutorials.html">tutorials in the User Guide</a>.</p>

<h2 id="part-3-fpga-synthesis">Part 3: FPGA Synthesis</h2>
<p>Support for <em>FPGA synthesis</em> and prebuilt example FPGA bitstreams are
available again. We currently focus on the
<a href="http://store.digilentinc.com/nexys-4-ddr-artix-7-fpga-trainer-board-recommended-for-ece-curriculum/">Nexys 4 DDR</a>
and the
<a href="https://www.xilinx.com/products/boards-and-kits/ek-k7-kc705-g.html">KC705</a>
boards. But as we have defined a good board abstraction layer now,
it is a lot easier to support other boards. Please get in
<a href="/getinvolved.html">touch with us</a> if you want to have another
board mainline supported.</p>

<h2 id="part-4-the-small-things">Part 4: The small things</h2>
<p>There were much more small changes throughout the system. Some things without special order.</p>

<ul>
  <li>We now use much more SystemVerilog. That’s still a bit tricky, because every tool supports a slightly different subset of features, but in general the benefits to code readability are significant.</li>
  <li>Our build system has improved a lot to the point that we now can build a full release including bitstreams with one command. We use this also to do automated builds on Travis for all checkins.</li>
</ul>

<h2 id="the-future-is-bright">The future is bright</h2>
<p>With this release we’ve layed a lot of groundwork for even faster progress in the future.
Some things are already in the pipeline, including a cool demo with live video streams.</p>

<p>We currently plan a project sprint and
<a href="https://github.com/optimsoc/sources/milestone/3">plan the next release</a>
for end of October with the following improvements:</p>

<ul>
  <li>
    <p>Re-activation of the <em>Partitioned Global Address Space</em> option</p>
  </li>
  <li>
    <p>Support for the KC705</p>
  </li>
  <li>
    <p>Improved <em>Network-on-Chip configuration</em> for better extendability</p>
  </li>
  <li>
    <p>Re-activation of the <em>multiple clock domains</em> support and maybe
dynamic clocks</p>
  </li>
</ul>

<p>Stay tuned and join us on <a href="/getinvolved.html">IRC or the mailing list</a>.</p>

<h2 id="contributors-to-this-release">Contributors to this release</h2>
<p>Without the work of many individuals, a project like OpTiMSoC would be impossible. We thank everybody who contributed to this release and the projects that we included into our release.</p>

<ul>
  <li>Nico Gutmann</li>
  <li>Olof Kindgren (on FuseSoC)</li>
  <li>Stefan Rösch</li>
  <li>Wei Song (on Open Soc Debug)</li>
  <li>Philipp Wagner</li>
  <li>Stefan Wallentowitz</li>
</ul>

<p>(This list is likely to be incomplete; if you’re missing, let us know!)</p>
</p>

  <h2><a href="/blog/2015/12/30/release.html">2015.1 Release and Back to Unified Tree</a></h2>
  <p class="optimsoc-blog-meta">by Stefan Wallentowitz, posted on 30 December 2015
  <p><p>Good news first: We have a put out a regular release and we promise to
do this more often. Until now there was not much sense to make
releases, because everything was in a flow and there was not even an
installation package. But this has changed, from now on regular
releases can be found on
<a href="https://github.com/optimsoc/sources/releases">github</a>. The release
numbers are numbered throughout the year (2015.1 on December 30 will
hopefully not happen again..).</p>

<p>We have also accordingly updated the <a href="/download.html">download
instruction</a>, pretty simple now, right?</p>

<p>Now to the kind of “bad” news: We are moving back from Google repo to
a unified source tree, plus extra repositories for demo apps, FPGA
target code, etc. It simply turned out that for people new to git, the
usage of repo is too challenging and time-consuming. Hence, you can
now find the unified source tree
<a href="https://github.com/optimsoc/sources">github</a>. We have brought in all
changes from the distributed repos again.</p>

<p>But to turn it into good news again, you can install from sources with
one simple installer script (a better one to come in 2016):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/optimsoc/sources optimsoc-sources
./optimsoc-sources/tools/install.py -d /opt/optimsoc/current
</code></pre></div></div>

<p>We are looking forward to a more active 2016 and wish you all a Happy
New Year!</p>

</p>

  <h2><a href="/blog/2015/05/16/repo.html">Switch to github organization and Google repo</a></h2>
  <p class="optimsoc-blog-meta">by Stefan Wallentowitz, posted on 16 May 2015
  <p><p>A few weeks ago we started cutting out the different parts of OpTiMSoC
from the <a href="https://github.com/tum-lis/optimsoc">original repository</a> to
separate repositories at the <a href="https://github.com/optimsoc/">new
organization</a>. The aim is to structure
it better and have separation of different aspects of OpTiMSoC.</p>

<p>The method of separating subtrees from the original tree with keeping
the history is straight forward using <code class="language-plaintext highlighter-rouge">git filter-branch</code>. Some parts
of the history get lost, especially for the system software.
Nevertheless, we now have cut the original large repository into
smaller logical units. Some of them are only needed for installation
if you simply want to run OpTiMSoC, others are needed to build systems
or for debugging.</p>

<p>Finally, we struggled a bit with still allowing for a unified tree
layout, which is desirable for the documentation and ease of use. We
wanted a tree similar to the original layout and inspected <code class="language-plaintext highlighter-rouge">git
submodule</code> and <code class="language-plaintext highlighter-rouge">git subtree</code>. Unfortunately both did not convince us
entirely, as we don’t want people to learn new merge strategies etc.</p>

<p>We first started with a simple shell script that initially creates the
layout. After some more search we came to <a href="https://code.google.com/p/git-repo/">Google
repo</a>, which is a git wrapper for
Android developers. While we don’t plan to use the entire feature set,
we use it to distribute the tree layout. The layout is distributed as
xml files and it is possible to define groups for different feature
sets.</p>

<p>To start a layout, simply create an empty folder, download the repo
script and make it executable:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir optimsoc
wget https://storage.googleapis.com/git-repo-downloads/repo
chmod a+x repo
</code></pre></div></div>

<p>Now you can initialize the repository layout. The script downloads
some more files from Google’s repositories and reads the remote xml
description into a local repository of the repository files, both in
the hidden path <code class="language-plaintext highlighter-rouge">.repo</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./repo init -u https://github.com/optimsoc/optimsoc-repo
</code></pre></div></div>

<p>You then synchronize the repositories and repo clones and puts them
into “detached HEAD” state.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ./repo sync
</code></pre></div></div>

<p>If you want to create a new feature branch for a part of OpTiMSoC you
can use the repo infrastructure or simply do this with the usual git
commands (create branch, stage, commit etc.). We are also still
experimenting with the best development strategies.</p>

</p>

  <h2><a href="/blog/2015/05/12/website.html">Website updates and mailing list</a></h2>
  <p class="optimsoc-blog-meta">by Stefan Wallentowitz, posted on 12 May 2015
  <p><p>Maybe not visible to the outside, but there has been a change in the
website rcently. We have updated the documentation, moved the entire
site to <a href="https://github.com/optimsoc/optimsoc.github.io">github pages</a>
and added some social media buttons to share the website or our blog
posts.</p>

<p>Also very important to mention we want to (re-)activate the mailing
list (<a href="mailto:optimsoc@lists.lrz.de">optimsoc.lists.lrz.de</a>). So if
you have any feedback, questions or ideas please feel free to send a
mail there. You can also subsribe to the list and always stay updated:</p>

<form class="form-inline" method="post" action="https://lists.lrz.de/mailman/subscribe/optimsoc">
  <div class="form-group">
    <label class="sr-only" for="email">e-mail address</label>
    <input type="text" class="form-control" placeholder="your-email@example.com" name="email" />
  </div>
  <button class="btn btn-primary" type="submit">Subscribe me!</button>
</form>

<p>As you might have noticed, we are also preparing a release, this time
seriously ;)</p>

</p>

  <h2><a href="/blog/2014/10/12/orconf2014.html">Many New Ideas from ORCONF</a></h2>
  <p class="optimsoc-blog-meta">by Philipp Wagner, posted on 12 October 2014
  <p><p>Every autumn the community around the OpenRISC processor meets somewhere to 
discuss the current status of the project, to exchange ideas with other 
free/open hardware projects, and to discuss future directions. This year the 
<a href="http://orconf.org">OpenRISC Conference “ORCONF”</a> was held at TUM in Munich and 
attracted around 40 people from all over Europe and the US.</p>

<p>The OpenRISC processor implementation “mor1kx” powers the the OpTiMSoC compute 
tiles, and we have been active in its development for some time now. So it was 
an easy call to make when the question of where to host the next conference 
came up: visit us in Munich!</p>

<p>What followed was a great weekend with many interesting talks. Olof started 
off with a status update on OpenRISC in general, followed by talks presenting 
the changes to the individual components of the OpenRISC project, such as 
toolchain and various porting efforts, e.g. of the Linux Kernel. How OpenRISC 
is used in the wild was shown by reports from research groups all over Europe, 
which are using the OpenRISC architecture as base of their SoC designs.</p>

<p>Implementing OpenRISC in JavaScript? Why not, thought Sebastian Macke a couple 
years ago, and out of this idea the <a href="http://s-macke.github.io/jor1k/">jor1k</a> 
emulator was born. In addition to some demos he showed us what’s necessary to 
implement a fast (80 MIPS on an iPad!) emulator in JavaScript.</p>

<p>The round of talks was completed by presentations of exciting 
upcoming topics such as the <a href="http://riscv.org/">RISC-V ISA</a> with its 
implementation, <a href="http://riscv.org/download.html#tab_rocket">Rocket</a>, the 
<a href="http://www.lowrisc.org/">lowRISC</a> project with the goal of building silicon in 
an open way, and various other topics related to free/open hardware design.</p>

<p>Thanks to everybody who joined us for the conference, and thanks for making 
OpenRISC a success!</p>

<p>Additional resources:</p>

<ul>
  <li><a href="https://www.flickr.com/photos/127858841@N06/sets/72157648274711327/">Pictures are available on Flickr</a>.</li>
  <li>The presentation slides are linked from the <a href="http://tum-lis.github.io/orconf2014/">ORCONF 2014 website</a>.</li>
  <li><a href="https://www.youtube.com/watch?v=96MN6lhLFRY&amp;list=PLOGTP9W1DX5XDdzBroA2i1ffMlCNus30M">Recordings of the talks are available on YouTube.</a></li>
</ul>

<iframe width="560" height="340" src="//www.youtube-nocookie.com/embed/qf-1hL6Cwhs?list=PLOGTP9W1DX5XDdzBroA2i1ffMlCNus30M" frameborder="0" allowfullscreen=""></iframe>

</p>

  <h2><a href="/blog/2014/07/30/glip.html">Switching Host-Communication to GLIP</a></h2>
  <p class="optimsoc-blog-meta">by Philipp Wagner, posted on 30 July 2014
  <p><p>Since its beginning, OpTiMSoC contained a method for communication between a 
PC and an FPGA board. For the ZTEX 1.15 boards we used the USB 2.0 interface, 
based on the Cypress FX2 chip available on those boards. As we continued the 
development, we realized that this connectivity functionality is not only 
useful in OpTiMSoC, but in other projects as well.</p>

<p>We now finally got around to factor the communication interface out of OpTiMSoC 
and to moved it into a new project, which we named the “Generic Logic Interface 
Project”, or in short, GLIP. It provides generic, FIFO-based communication 
between a host and a target, abstracting away all the nitty gritty details and 
protocols in between. It lets you simply focus on the data you want to transfer, 
handling everything else for you.</p>

<p>As of now GLIP contains a cleaned-up and improved version of the Cypress 
FX2-based USB 2.0 backend, reaching up to 21 MByte/s bi-directional transfer 
rate (close to the achievable maximum of the USB 2.0 interface), and a 
host-only TCP backend for communication between a simulated system (e.g. in 
ModelSim) and a controller.</p>

<p>In the near future, other backends for JTAG and possibly PCIe are planned.</p>

<p>We provide GLIP with an extensive set of documentation under the MIT license, 
check it out!</p>

<ul>
  <li><a href="http://lis.ei.tum.de/glip/">Project page and documentation</a></li>
  <li><a href="https://github.com/TUM-LIS/glip">Source code on GitHub</a></li>
</ul>

<p>With the newest latest trunk version of OpTiMSoC liboptimsochost uses GLIP for 
all Debug NoC based communications, so you need to have GLIP installed if you 
want to use those as of now.</p>

<p>Enjoy!</p>
</p>

  <h2><a href="/blog/2014/01/03/fosdem.html">OpTiMSoC at FOSDEM</a></h2>
  <p class="optimsoc-blog-meta">by Philipp Wagner, posted on 03 January 2014
  <p><p>It’s official! We are proud to announce that our talk at <a href="http://fosdem.org">FOSDEM</a>
has been accepted. FOSDEM, for those of you who have never heard of it, is one of
the largest Free/Open Source conferences in Europe with a very strong focus on
developers and technology. It is held every year in Brusseles, Belgium. This year it
takes place on February 1st and 2nd.</p>

<p>Since we don’t expect the whole audience to be very deep into hardware design we
will first give a short introduction of how SoC design is done these days, and then
showcase some cool things you can do with OpTiMSoC. More information about the talk
is available at the
<a href="https://fosdem.org/2014/schedule/event/optimisoc/">conference homepage</a>.</p>

<p>I will be attending the whole conference, let me know if you’re around. I’d love to
hear from you if you have problems with OpTiMSoC or ideas on how to make it better.
See you at FOSDEM!</p>

<p><strong>Update:</strong> The nice people at FOSDEM also published a short interview with me about the
talk.
<a href="https://fosdem.org/2014/interviews/2014-philipp-wagner/">Find it on the FOSDEM page!</a></p>

<p><strong>Update 2:</strong> Now the recorded video is online as well.
<a href="http://video.fosdem.org/2014/K1105/Sunday/OpTiMSoC.webm">Download the video</a>
or watch it below! The
<a href="/documents/presentations/2014-fosdem-slides.pdf">slides are available online</a>
as well.</p>

<video width="640" height="480" style="display: block; margin-left: auto; margin-right: auto" src="http://video.fosdem.org/2014/K1105/Sunday/OpTiMSoC.webm" controls="">
  Unfortunately your browser does not support WebM video playback. Use a supported
  browser, such as Firefox or Chrome, or download the video and play it with another
  application, such as the free VLC player.
</video>

</p>

  <h2><a href="/blog/2013/10/30/orconf2013.html">OpTiMSoC at ORCONF 2013</a></h2>
  <p class="optimsoc-blog-meta">by Philipp Wagner, posted on 30 October 2013
  <p><p>The “brain” in a SoC is its processor; in OpTiMSoC this task falls to a 
the freely available OpenRISC processor. For the second year now the developers
of the OpenRISC processor met in Cambridge, UK for a two-day conference on 
October 5th and 6th to discuss the current status of the project as well as
plans for the future.</p>

<p>Stefan attended this conference and came home with a lot of new ideas and 
information, which we’ll incorporate into OpTiMSoC in the future. But he was
also able to give a 45 minute presentation about OpTiMSoC, what it is, and how
you can make use of it. The whole talk was recorded, you can watch it down
below or on <a href="http://www.youtube.com/watch?v=gEf7EFahvAQ">YouTube</a>. Enjoy!</p>

<iframe width="560" height="340" src="http://www.youtube.com/embed/gEf7EFahvAQ" frameborder="0" allowfullscreen=""></iframe>

</p>

  <h2><a href="/blog/2013/08/27/welcome.html">OpTiMSoC has a new web site!</a></h2>
  <p class="optimsoc-blog-meta">by Philipp Wagner, posted on 27 August 2013
  <p><p>OpTiMSoC is growing rapidly. Most of the time we have our heads deep down into
the internals, chasing large and small bugs, implementing exciting new features
and if it all works, enjoy a beer at night.</p>

<p>Then last weekend I thought about how we present all our work to the
public – and as you might have guessed, there’s some room for improvement.
As a first step we decided to redesign our homepage, giving it more content
to help you understand what OpTiMSoC is, where you can get all the necessary
parts to get started and how you can become part of the OpTiMSoC world.</p>

<p>We hope you like it and please get back to us with any feedback you might have.</p>
</p>


</div>


  <!-- footer -->
  <hr>
  <footer class="optimsoc-footer">
    <p>OpTiMSoC &copy; 2012-2021 OpTiMSoC Maintainers &middot; Imprint</p>
  </footer>

  <script src="//code.jquery.com/jquery-1.11.3.min.js"></script>
  <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
</body>
</html>
